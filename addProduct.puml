@startuml Add_Product_to_Cart_Full
title Add Product to Cart - Complete Flow (Frontend + Backend)

actor User
participant ProductCard
participant CartContext
participant CartService
participant LocalCartService
participant ApiCartService
participant "Frontend API" as FrontendAPI
participant CartController
participant CartService as BackendCartService
participant CartItemRepository
participant ProductRepository
participant Database

User -> ProductCard: Click "Add to Cart" button
ProductCard -> CartContext: addToCart(product, quantity)
CartContext -> CartService: addToCart(product, quantity)
CartService -> CartService: updateCartServiceReference()

alt User is authenticated
    CartService -> ApiCartService: addToCart(product, quantity)
    ApiCartService -> FrontendAPI: POST /api/cart/add
    FrontendAPI -> CartController: addToCart(cartItemDTO)
    
    CartController -> BackendCartService: addToCart(cartItemDTO, userId)
    BackendCartService -> ProductRepository: findById(productId)
    ProductRepository -> Database: SELECT * FROM products WHERE id = ?
    Database --> ProductRepository: Product data
    ProductRepository --> BackendCartService: Product entity
    
    alt Product exists and has stock
        BackendCartService -> CartItemRepository: findByUserIdAndProductId(userId, productId)
        CartItemRepository -> Database: SELECT * FROM cart_items WHERE user_id = ? AND product_id = ?
        Database --> CartItemRepository: Existing cart item (if any)
        CartItemRepository --> BackendCartService: CartItem entity
        
        alt Cart item exists
            BackendCartService -> BackendCartService: updateQuantity(existingItem, newQuantity)
            BackendCartService -> CartItemRepository: save(updatedCartItem)
        else Cart item doesn't exist
            BackendCartService -> BackendCartService: createNewCartItem(product, quantity, userId)
            BackendCartService -> CartItemRepository: save(newCartItem)
        end
        
        CartItemRepository -> Database: INSERT/UPDATE cart_items
        Database --> CartItemRepository: Success
        CartItemRepository --> BackendCartService: Saved CartItem
        BackendCartService --> CartController: CartItemDTO
        CartController --> FrontendAPI: 200 OK + CartItemDTO
        FrontendAPI --> ApiCartService: CartItem response
        ApiCartService --> CartService: CartItem
    else Product out of stock or doesn't exist
        BackendCartService --> CartController: throw BadRequestException("Product not available")
        CartController --> FrontendAPI: 400 Bad Request
        FrontendAPI --> ApiCartService: Error response
        ApiCartService --> CartService: Throw error
    end
    
else User not authenticated
    CartService -> LocalCartService: addToCart(product, quantity)
    LocalCartService -> LocalCartService: getCartItems() from localStorage
    LocalCartService -> LocalCartService: addOrUpdateItem(product, quantity)
    LocalCartService -> LocalCartService: saveCart(cartItems) to localStorage
    LocalCartService --> CartService: CartItem
end

CartService --> CartContext: CartItem/Error
CartContext -> CartContext: loadCartItems()
CartContext --> ProductCard: Success/Error
ProductCard -> ProductCard: Show success/error message
ProductCard --> User: Display confirmation/error

@enduml

->

@startuml Add_Product_to_Cart_Full
title Add Product to Cart - Complete Flow (Frontend + Backend)

actor User
participant ProductCard
participant CartContext
participant CartService
participant LocalCartService
participant ApiCartService
participant "Frontend API" as FrontendAPI
participant CartController
participant CartService as BackendCartService
participant CartItemRepository
participant ProductRepository
participant Database

User -> ProductCard: Click "Add to Cart" button
ProductCard -> CartContext: addToCart(product, quantity)
CartContext -> CartService: addToCart(product, quantity)
CartService -> CartService: updateCartServiceReference()

alt User is authenticated
    CartService -> ApiCartService: addToCart(product, quantity)
    ApiCartService -> FrontendAPI: POST /api/cart/add
    FrontendAPI -> CartController: addToCart(cartItemDTO)
    
    CartController -> BackendCartService: addToCart(cartItemDTO, userId)
    BackendCartService -> ProductRepository: findById(productId)
    ProductRepository -> Database: SELECT * FROM products WHERE id = ?
    Database --> ProductRepository: Product data
    ProductRepository --> BackendCartService: Product entity
    
    alt Product exists and has stock
        BackendCartService -> CartItemRepository: findByUserIdAndProductId(userId, productId)
        CartItemRepository -> Database: SELECT * FROM cart_items WHERE user_id = ? AND product_id = ?
        Database --> CartItemRepository: Existing cart item (if any)
        CartItemRepository --> BackendCartService: CartItem entity
        
        alt Cart item exists
            BackendCartService -> BackendCartService: updateQuantity(existingItem, newQuantity)
            BackendCartService -> CartItemRepository: save(updatedCartItem)
        else Cart item doesn't exist
            BackendCartService -> BackendCartService: createNewCartItem(product, quantity, userId)
            BackendCartService -> CartItemRepository: save(newCartItem)
        end
        
        CartItemRepository -> Database: INSERT/UPDATE cart_items
        Database --> CartItemRepository: Success
        CartItemRepository --> BackendCartService: Saved CartItem
        BackendCartService --> CartController: CartItemDTO
        CartController --> FrontendAPI: 200 OK + CartItemDTO
        FrontendAPI --> ApiCartService: CartItem response
        ApiCartService --> CartService: CartItem
    else Product out of stock or doesn't exist
        BackendCartService --> CartController: throw BadRequestException("Product not available")
        CartController --> FrontendAPI: 400 Bad Request
        FrontendAPI --> ApiCartService: Error response
        ApiCartService --> CartService: Throw error
    end
    
else User not authenticated
    CartService -> LocalCartService: addToCart(product, quantity)
    LocalCartService -> LocalCartService: getCartItems() from localStorage
    LocalCartService -> LocalCartService: addOrUpdateItem(product, quantity)
    LocalCartService -> LocalCartService: saveCart(cartItems) to localStorage
    LocalCartService --> CartService: CartItem
end

CartService --> CartContext: CartItem/Error
CartContext -> CartContext: loadCartItems()
CartContext --> ProductCard: Success/Error
ProductCard -> ProductCard: Show success/error message
ProductCard --> User: Display confirmation/error

@enduml

@startuml Update_Cart_Item_Full
title Update Cart Item - Complete Flow (Frontend + Backend)

actor User
participant CartPage
participant CartContext
participant CartService
participant LocalCartService
participant ApiCartService
participant "Frontend API" as FrontendAPI
participant CartController
participant CartService as BackendCartService
participant CartItemRepository
participant ProductRepository
participant Database

User -> CartPage: Change quantity in cart
CartPage -> CartContext: updateCartItem(product, newQuantity)
CartContext -> CartService: updateCartItem(product, newQuantity)
CartService -> CartService: updateCartServiceReference()

alt User is authenticated
    CartService -> ApiCartService: updateCartItem(product, newQuantity)
    ApiCartService -> FrontendAPI: PUT /api/cart/update
    FrontendAPI -> CartController: updateCartItem(cartItemDTO)
    
    CartController -> BackendCartService: updateCartItem(cartItemDTO, userId)
    BackendCartService -> CartItemRepository: findByUserIdAndProductId(userId, productId)
    CartItemRepository -> Database: SELECT * FROM cart_items WHERE user_id = ? AND product_id = ?
    Database --> CartItemRepository: CartItem entity
    CartItemRepository --> BackendCartService: CartItem
    
    alt CartItem exists
        BackendCartService -> ProductRepository: findById(productId)
        ProductRepository -> Database: SELECT * FROM products WHERE id = ?
        Database --> ProductRepository: Product data
        ProductRepository --> BackendCartService: Product entity
        
        alt Sufficient stock available
            BackendCartService -> BackendCartService: validateQuantity(newQuantity, product.quantity)
            BackendCartService -> CartItemRepository: save(updatedCartItem)
            CartItemRepository -> Database: UPDATE cart_items SET quantity = ? WHERE id = ?
            Database --> CartItemRepository: Success
            CartItemRepository --> BackendCartService: Updated CartItem
            BackendCartService --> CartController: CartItemDTO
            CartController --> FrontendAPI: 200 OK + CartItemDTO
            FrontendAPI --> ApiCartService: Updated CartItem
            ApiCartService --> CartService: Updated CartItem
        else Insufficient stock
            BackendCartService --> CartController: throw BadRequestException("Not enough stock available")
            CartController --> FrontendAPI: 400 Bad Request + error message
            FrontendAPI --> ApiCartService: Error: Not enough stock
            ApiCartService --> CartService: Throw error with message
        end
    else CartItem not found
        BackendCartService --> CartController: throw NotFoundException("Cart item not found")
        CartController --> FrontendAPI: 404 Not Found
        FrontendAPI --> ApiCartService: Error response
        ApiCartService --> CartService: Throw error
    end
    
else User not authenticated
    CartService -> LocalCartService: updateCartItem(product, newQuantity)
    LocalCartService -> LocalCartService: getCartItems() from localStorage
    LocalCartService -> LocalCartService: findCartItem(product.productID)
    LocalCartService -> LocalCartService: updateItemQuantity(item, newQuantity)
    LocalCartService -> LocalCartService: saveCart(updatedItems) to localStorage
    LocalCartService --> CartService: Updated CartItem
end

alt Error occurred
    CartService --> CartContext: Throw error
    CartContext -> CartContext: loadCartItems() to refresh
    CartContext --> CartPage: Error message
    CartPage --> User: Show error notification
else Success
    CartService --> CartContext: Updated CartItem
    CartContext -> CartContext: loadCartItems()
    CartContext --> CartPage: Success
    CartPage --> User: Update cart display
end

@enduml

@startuml View_Product_Details_Full
title View Product Details - Complete Flow (Frontend + Backend)

actor User
participant ProductDetailPage
participant ProductService
participant "Frontend API" as FrontendAPI
participant ProductController
participant ProductService as BackendProductService
participant ProductRepository
participant BookRepository
participant CDRepository
participant DVDRepository
participant Database
participant CartContext
participant CartService

User -> ProductDetailPage: Navigate to /products/:id
ProductDetailPage -> ProductService: getProductById(id)

alt Backend available
    ProductService -> FrontendAPI: GET /api/products/:id
    FrontendAPI -> ProductController: getProductById(id)
    ProductController -> BackendProductService: getProductById(id)
    
    BackendProductService -> ProductRepository: findById(id)
    ProductRepository -> Database: SELECT * FROM products WHERE product_id = ?
    Database --> ProductRepository: Product base data
    ProductRepository --> BackendProductService: Product entity
    
    alt Product found
        BackendProductService -> BackendProductService: determineProductType(product.category)
        
        alt Product is Book
            BackendProductService -> BookRepository: findById(id)
            BookRepository -> Database: SELECT * FROM books WHERE product_id = ?
            Database --> BookRepository: Book details
            BookRepository --> BackendProductService: Book entity
            BackendProductService -> BackendProductService: mapToBookDTO(book)
        else Product is CD
            BackendProductService -> CDRepository: findById(id)
            CDRepository -> Database: SELECT * FROM cds WHERE product_id = ?
            Database --> CDRepository: CD details
            CDRepository --> BackendProductService: CD entity
            BackendProductService -> BackendProductService: mapToCdDTO(cd)
        else Product is DVD
            BackendProductService -> DVDRepository: findById(id)
            DVDRepository -> Database: SELECT * FROM dvds WHERE product_id = ?
            Database --> DVDRepository: DVD details
            DVDRepository --> BackendProductService: DVD entity
            BackendProductService -> BackendProductService: mapToDvdDTO(dvd)
        end
        
        BackendProductService --> ProductController: ProductDTO with specific details
        ProductController --> FrontendAPI: 200 OK + ProductDTO
        FrontendAPI --> ProductService: Product data
        ProductService --> ProductDetailPage: Product details
    else Product not found
        BackendProductService --> ProductController: throw ResourceNotFoundException("Product not found")
        ProductController --> FrontendAPI: 404 Not Found
        FrontendAPI --> ProductService: Error response
        ProductService --> ProductDetailPage: Error
    end
    
else Backend error
    ProductService -> ProductService: getMockProducts()
    ProductService -> ProductService: Find product in mock data
    ProductService --> ProductDetailPage: Mock product data
end

ProductDetailPage -> ProductService: getMockProducts() for related products
ProductService --> ProductDetailPage: Related products list

ProductDetailPage -> ProductDetailPage: renderCategorySpecificInfo()
ProductDetailPage --> User: Display product details page

note over User, CartService: Add to Cart from Product Detail

User -> ProductDetailPage: Select quantity and click "Add to Cart"
ProductDetailPage -> CartContext: addToCart(product, quantity)
note right of CartContext: Same flow as Add Product to Cart diagram
CartContext --> ProductDetailPage: Success/Error response

alt Success
    ProductDetailPage -> ProductDetailPage: setCartMessage("Product added successfully!")
    ProductDetailPage -> ProductDetailPage: setQuantity(1) // Reset quantity
    ProductDetailPage --> User: Show success message
else Error
    ProductDetailPage -> ProductDetailPage: setCartMessage("Failed to add: " + error)
    ProductDetailPage -> ProductDetailPage: loadProductDetails() // Refresh product data
    ProductDetailPage --> User: Show error message
end

@enduml

@startuml Search_Product_Full
title Search Product - Complete Flow (Frontend + Backend)

actor User
participant ProductsPage
participant Header
participant ProductService
participant "Frontend API" as FrontendAPI
participant ProductController
participant ProductService as BackendProductService
participant ProductRepository
participant BookRepository
participant CDRepository
participant DVDRepository
participant Database

alt Search from Header
    User -> Header: Enter search query and submit
    Header -> Header: handleSearch(e)
    Header -> Header: navigate("/products?search=" + query)
else Search from Products Page
    User -> ProductsPage: Enter search in filter section
    ProductsPage -> ProductsPage: handleFilterChange("search", value)
end

ProductsPage -> ProductsPage: useEffect triggered by filter change
ProductsPage -> ProductsPage: loadProducts(page)
ProductsPage -> ProductService: fetchProducts(filters, page, pageSize)

ProductService -> ProductService: Build URLSearchParams from filters
note right of ProductService: Include keyword, category, minPrice, maxPrice, sortBy, page, size

ProductService -> FrontendAPI: GET /api/products?keyword=query&category=book&minPrice=100000&maxPrice=500000&sortBy=price_asc&page=0&size=12

FrontendAPI -> ProductController: getFilteredProducts(keyword, category, minPrice, maxPrice, sortBy, pageable)
ProductController -> BackendProductService: getFilteredProducts(keyword, category, minPrice, maxPrice, sortBy, page, size)

BackendProductService -> BackendProductService: createPageable(page, size, sortBy)
BackendProductService -> BackendProductService: parseCategory(category)
BackendProductService -> BackendProductService: buildSortCriteria(sortBy)

BackendProductService -> ProductRepository: searchProducts(keyword, categoryEnum, minPrice, maxPrice, pageable)
ProductRepository -> Database: Complex SQL Query with filters
note right of Database: SELECT p.* FROM products p\nWHERE (:keyword IS NULL OR LOWER(p.title) LIKE LOWER(CONCAT('%', :keyword, '%')))\nAND (:category IS NULL OR p.category = :category)\nAND (:minPrice IS NULL OR p.price >= :minPrice)\nAND (:maxPrice IS NULL OR p.price <= :maxPrice)\nORDER BY [sortBy criteria]\nLIMIT :size OFFSET :offset

Database --> ProductRepository: Page<Product> with filtered results
ProductRepository --> BackendProductService: Page<Product>

BackendProductService -> BackendProductService: convertToProductDTOs(productPage)

loop For each product in page
    BackendProductService -> BackendProductService: determineProductStrategy(product.category)
    
    alt Product is Book
        BackendProductService -> BackendProductService: bookStrategy.getProductById(product.id)
        BackendProductService -> BookRepository: findById(product.id)
        BookRepository -> Database: SELECT * FROM books WHERE product_id = ?
        Database --> BookRepository: Book details
        BookRepository --> BackendProductService: BookDTO
    else Product is CD
        BackendProductService -> BackendProductService: cdStrategy.getProductById(product.id)
        BackendProductService -> CDRepository: findById(product.id)
        CDRepository -> Database: SELECT * FROM cds WHERE product_id = ?
        Database --> CDRepository: CD details
        CDRepository --> BackendProductService: CdDTO
    else Product is DVD
        BackendProductService -> BackendProductService: dvdStrategy.getProductById(product.id)
        BackendProductService -> DVDRepository: findById(product.id)
        DVDRepository -> Database: SELECT * FROM dvds WHERE product_id = ?
        Database --> DVDRepository: DVD details
        DVDRepository --> BackendProductService: DvdDTO
    end
end

BackendProductService -> BackendProductService: createPagedResponse(productDTOs, page, size, totalElements)
BackendProductService --> ProductController: PagedResponse<ProductDTO>
ProductController --> FrontendAPI: 200 OK + PagedResponse

alt Backend success
    FrontendAPI --> ProductService: PagedResponse with filtered products
    ProductService --> ProductsPage: { content: products[], totalPages, totalElements }
    ProductsPage -> ProductsPage: setProducts(response.content)
    ProductsPage -> ProductsPage: setTotalPages(response.totalPages)
    ProductsPage --> User: Display filtered products with pagination
else Backend error
    FrontendAPI --> ProductService: Error response
    ProductService --> ProductsPage: Throw error
    ProductsPage -> ProductsPage: setError(error.message)
    ProductsPage -> ProductsPage: setProducts([])
    ProductsPage --> User: Display error message
end

note over User, Database: URL and State Management
ProductsPage -> ProductsPage: updateURL(filters, page)
ProductsPage -> ProductsPage: setSearchParams(urlParams)
note right of ProductsPage: URL reflects current search state\nfor bookmarking and sharing

@enduml